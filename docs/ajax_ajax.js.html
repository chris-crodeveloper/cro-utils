<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ajax/ajax.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ajax/ajax.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Ajax Utility functions
 * @category Ajax Utils
 * @module AjaxUtils
 */

/**
 * Make HTTP Fetch API call returning the JSON in the promise resolve
 * @function fetchApi
 * @param {string} httpMethod - GET, POST
 * @param {string} url - URL
 * @param {object} payload - body
 * @param {object} headers - HTTP Headers
 * @returns {object} promise
 */
export const fetchApi = (httpMethod, url, payload, headers) => {
  let httpHeaders = new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
  });
  if (headers) {
    headers.forEach((value, key) => {
      httpHeaders.append(key, value);
    });
  }
  return new Promise((resolve, reject) => {
    let options = { method: httpMethod, headers: httpHeaders };
    if ((httpMethod === "POST" || httpMethod === "PATCH") &amp;&amp; payload) {
      options = { ...options, body: JSON.stringify(payload) };
    }

    fetch(url, options)
      .then((response) => {
        if (response) {
          if (response.ok) {
            return response.json();
          }
          return response.json().then((error) => {
            console.log(error);
            reject(error);
          });
        }
      })
      .then((jsonData) => {
        console.log(`${httpMethod}: ${url}`, jsonData);

        resolve(jsonData);
      })
      .catch((error) => {
        console.log(`${httpMethod}: ${url}`, error);
        reject(error);
      });
  });
};

/**
 * This callback is displayed as a global member.
 * @callback interceptAjaxResponseCallback
 * @param {string} responseURL - Ajax Response URL
 * @param {string} responseText - Ajax response Text
 */

/**
 * Intercepts AJAX requests by overwriting the XMLHttpRequest prototype.
 * @function interceptAjaxResponse
 * @param {string} pageUrl - The page URL that this function is required on. This is important as the function should be restricted as much as possible
 * @param {string} responseURL - The specific AJAX response URL the data is required from
 * @param {boolean} pageURLsubstringMatch - If true - the pageURL can be matched as a substring. If false, the pageURL is matched as an absolute match
 * @param {boolean} responseURLsubstringMatch - If true - the responseURL can be matched as a substring. If false, the responseURL is matched as an absolute match
 * @param {interceptAjaxResponseCallback} cb - callback. returning the RepsonseURL and the RepsonseText
 */
export const interceptAjaxResponse = (
  pageUrl,
  responseURL,
  pageURLsubstringMatch,
  responseURLsubstringMatch,
  cb
) => {
  // Check if the URL is a match
  if (pageURLsubstringMatch) {
    if (document.location.href.indexOf(pageUrl) === -1) {
      return;
    }
  } else {
    if (document.location.href !== pageUrl) {
      return;
    }
  }

  // Update the AJAX prototype
  const send = XMLHttpRequest.prototype.send;

  XMLHttpRequest.prototype.send = function () {
    this.addEventListener("load", function () {
      try {
        if (this &amp;&amp; this.responseURL &amp;&amp; this.responseText) {
          // Look for responseURL before changing code
          if (responseURLsubstringMatch) {
            if (this.responseURL.indexOf(responseURL) > -1) {
              const responseURL = this.responseURL;
              const responseText = this.responseText;
              cb(responseURL, responseText);
            }
          } else {
            if (this.responseURL === responseURL) {
              const responseURL = this.responseURL;
              const responseText = this.responseText;
              cb(responseURL, responseText);
            }
          }
        }
      } catch (error) {
        console.log("interceptAjaxResponse Error: " + error);
      }
    });

    return send.apply(this, arguments);
  };
};

/**
 * Generate UUID for creating AJAX requests
 * @function getUUID
 * @returns {string} returns random 16 char length string
 */
export const getUUID = () => {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
    (
      c ^
      (crypto.getRandomValues(new Uint8Array(1))[0] &amp; (15 >> (c / 4)))
    ).toString(16)
  );
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-AjaxUtils.html">AjaxUtils</a></li><li><a href="module-Common%2520Utils.html">Common Utils</a></li><li><a href="module-CookiesUtils.html">CookiesUtils</a></li><li><a href="module-ErrorHandlingUtils.html">ErrorHandlingUtils</a></li><li><a href="module-Gestures.html">Gestures</a></li><li><a href="module-OptimizelyUtils.html">OptimizelyUtils</a></li><li><a href="module-SafeUtils.html">SafeUtils</a></li><li><a href="module-WaitForUtils.html">WaitForUtils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Tue Aug 20 2024 17:35:57 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
